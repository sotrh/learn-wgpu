(window.webpackJsonp=window.webpackJsonp||[]).push([[70],{515:function(e,t,a){"use strict";a.r(t);var n=a(14),s=Object(n.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"update-to-wgpu-26-0-1-and-started-compute-pipeline-guide"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#update-to-wgpu-26-0-1-and-started-compute-pipeline-guide"}},[e._v("#")]),e._v(" Update to wgpu 26.0.1 and started compute pipeline guide")]),e._v(" "),t("p",[e._v("I've technically had the update to 26.0 done for awhile now, but I ran into some\nissues.")]),e._v(" "),t("ol",[t("li",[e._v("There was a bug in the Windows implementation that caused the viewport to\nflicker. This has since been fixed in version 26.0.1")]),e._v(" "),t("li",[e._v("There is a bug in how wgpu and winit interact in WASM on Windows. There's a feedback\nloop where on systems where the "),t("a",{attrs:{href:"https://developer.mozilla.org/en-US/docs/Web/API/Window/devicePixelRatio",target:"_blank",rel:"noopener noreferrer"}},[e._v("devicePixelRatio"),t("OutboundLink")],1),e._v("\nis greater than "),t("code",[e._v("1")]),e._v(" which means when wgpu resizes the canvas with "),t("code",[e._v("surface.configure()")]),e._v(",\nwinit emits and event and reports it as bigger than what wgpu is using. This causes\nthe demo code to call "),t("code",[e._v("surface.configure()")]),e._v(" again. This loop goes on until the surface\nsize exceeds the maximum values that wgpu supports causing wgpu to panic. Here's the\n"),t("a",{attrs:{href:"https://github.com/gfx-rs/wgpu/issues/7938#issuecomment-3079523549",target:"_blank",rel:"noopener noreferrer"}},[e._v("tracking issue"),t("OutboundLink")],1),e._v("\nin case you're interested. In the mean time users have found a work around\nfor this by constraining the canvas to a particular size. This bit of css is\nall you need to get prevent the issue:")])]),e._v(" "),t("div",{staticClass:"language-css extra-class"},[t("pre",{pre:!0,attrs:{class:"language-css"}},[t("code",[e._v("\n        "),t("span",{pre:!0,attrs:{class:"token selector"}},[e._v("canvas")]),e._v(" "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("{")]),e._v("\n            "),t("span",{pre:!0,attrs:{class:"token property"}},[e._v("width")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v(" 100%"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n            "),t("span",{pre:!0,attrs:{class:"token property"}},[e._v("height")]),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(":")]),e._v(" 100%"),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v(";")]),e._v("\n        "),t("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("}")]),e._v("\n")])])]),t("div",{staticClass:"note"},[t("p",[e._v("Technically you only need the "),t("code",[e._v("width: 100%")]),e._v(" part. Basically you just need to make\nthe browser in charge of what size the canvas should be.")])]),e._v(" "),t("h2",{attrs:{id:"what-s-changed"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#what-s-changed"}},[e._v("#")]),e._v(" What's changed")]),e._v(" "),t("p",[e._v("Since "),t("code",[e._v("wasm-pack")]),e._v(" is "),t("a",{attrs:{href:"https://blog.rust-lang.org/inside-rust/2025/07/21/sunsetting-the-rustwasm-github-org/",target:"_blank",rel:"noopener noreferrer"}},[e._v("no longer being maintained"),t("OutboundLink")],1),e._v("\nby the Rust Foundation, I've opted to use the fork of wasm-pack found at:\n"),t("a",{attrs:{href:"https://drager.github.io/wasm-pack/",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://drager.github.io/wasm-pack/"),t("OutboundLink")],1),e._v(". This works just fine, though I have\nconsidered switching to other alternatives such as trunk. No plans at the\nmoment, as I have other projects at the moment.")]),e._v(" "),t("p",[e._v("Scrolling through the "),t("code",[e._v("git diff")]),e._v(" most of the other changes are "),t("code",[e._v("Cargo.toml")]),e._v(" changes\nand some typo fixes. For a full list of the changes to wgpu itself, checkout the\n"),t("a",{attrs:{href:"https://github.com/gfx-rs/wgpu/releases",target:"_blank",rel:"noopener noreferrer"}},[e._v("changelog"),t("OutboundLink")],1),e._v(". Also if you find any issues you can\nsubmit a PR "),t("a",{attrs:{href:"https://github.com/sotrh/learn-wgpu/pulls",target:"_blank",rel:"noopener noreferrer"}},[e._v("here"),t("OutboundLink")],1),e._v("!")]),e._v(" "),t("h2",{attrs:{id:"something-new"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#something-new"}},[e._v("#")]),e._v(" Something new...")]),e._v(" "),t("p",[e._v("For awhile now, I've been debating what next to do with this collection. While\nthere are a whole score of graphics topics that I could cover (mipmapping,\nindirect drawing, hardware raytracing, shadows, skeletal animation, PBR, etc.), I have not\ndecided how I want the graphics guide to flow. I've even considered rewriting that\nsection to have a more specific goal in mind such as a game or model viewer.")]),e._v(" "),t("p",[e._v("I still wanted to add some more value especially for my supportive patrons. So\nI decided to cover a topic that I've been interested in for awhile: compute pipelines.\nAt this point in time I only have an introduction up, but I've started work on an\nexample on sorting data in compute shaders and I'm researching methods of filtering\ndata as well for techniques such as culling. I'm also trying a new writing style with\na bit less code dumps, so let me know what you think.")]),e._v(" "),t("p",[e._v("Check it out "),t("RouterLink",{attrs:{to:"/compute/introduction/"}},[e._v("here")]),e._v("!")],1),e._v(" "),t("h2",{attrs:{id:"thanks-to-my-patrons"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#thanks-to-my-patrons"}},[e._v("#")]),e._v(" Thanks to my patrons!")]),e._v(" "),t("p",[e._v("If you like what I do, and want to support me check out my "),t("a",{attrs:{href:"https://patreon.com/sotrh",target:"_blank",rel:"noopener noreferrer"}},[e._v("patreon"),t("OutboundLink")],1),e._v("!\nA special shoutout to these members!")]),e._v(" "),t("ul",[t("li",[e._v("Filip")]),e._v(" "),t("li",[e._v("Lions Heart")]),e._v(" "),t("li",[e._v("Jani Turkia")]),e._v(" "),t("li",[e._v("Julius Liu")]),e._v(" "),t("li",[e._v("折登 樹")]),e._v(" "),t("li",[e._v("Aron Granberg")]),e._v(" "),t("li",[e._v("Ian Gowen")]),e._v(" "),t("li",[e._v("Bernard Llanos")]),e._v(" "),t("li",[e._v("David Laban")]),e._v(" "),t("li",[e._v("Feng Liang")]),e._v(" "),t("li",[e._v("papyDoctor")]),e._v(" "),t("li",[e._v("dadofboi")]),e._v(" "),t("li",[e._v("Davide Prati")]),e._v(" "),t("li",[e._v("Andrea Postal")]),e._v(" "),t("li",[e._v("大典 加藤")]),e._v(" "),t("li",[e._v("Tema")]),e._v(" "),t("li",[e._v("Felix")]),e._v(" "),t("li",[e._v("Mattia Samiolo")]),e._v(" "),t("li",[e._v("Ken K")]),e._v(" "),t("li",[e._v("Ryan")]),e._v(" "),t("li",[e._v("Zeh Fernando")]),e._v(" "),t("li",[e._v("Craft Links")]),e._v(" "),t("li",[e._v("Ben Anderson")]),e._v(" "),t("li",[e._v("Thunk")]),e._v(" "),t("li",[e._v("Eliot Bolduc")]),e._v(" "),t("li",[e._v("yutani")]),e._v(" "),t("li",[e._v("charlesk")]),e._v(" "),t("li",[e._v("Danny McGee")]),e._v(" "),t("li",[e._v("Alexander Kabirov")]),e._v(" "),t("li",[e._v("Youngsuk Kim")]),e._v(" "),t("li",[e._v("Dude")]),e._v(" "),t("li",[e._v("Nico Arbogast")]),e._v(" "),t("li",[e._v("Gunstein Vatnar")]),e._v(" "),t("li",[e._v("Paul E Hansen")]),e._v(" "),t("li",[e._v("Joris Willems")]),e._v(" "),t("li",[e._v("Jan Šipr")]),e._v(" "),t("li",[e._v("Lennart")])])])}),[],!1,null,null,null);t.default=s.exports}}]);