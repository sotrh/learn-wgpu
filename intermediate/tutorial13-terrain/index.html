<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Procedural Terrain | Learn Wgpu</title>
    <meta name="generator" content="VuePress 1.9.7">
    
    <meta name="description" content="">
    <meta property="article:modified_time" content="2022-10-20T16:12:57.000Z">
    <meta property="og:site_name" content="Learn Wgpu">
    <meta property="og:title" content="Procedural Terrain">
    <meta property="og:type" content="website">
    <meta property="og:url" content="/intermediate/tutorial13-terrain/">
    <meta name="twitter:title" content="Procedural Terrain">
    <meta name="twitter:url" content="/intermediate/tutorial13-terrain/">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:label1" content="Written by">
    <meta name="twitter:data1" content="Benjamin Hansen">
    <meta name="twitter:creator" content="https://twitter.com/sotrh760">
    
    <link rel="preload" href="/learn-wgpu/assets/css/1.styles.a09ac8f8.css" as="style"><link rel="preload" href="/learn-wgpu/assets/js/app.fbe9e6a8.js" as="script"><link rel="preload" href="/learn-wgpu/assets/js/15.656a9cc4.js" as="script"><link rel="preload" href="/learn-wgpu/assets/js/22.a7ceb9be.js" as="script"><link rel="prefetch" href="/learn-wgpu/assets/js/0.5a1994c5.js"><link rel="prefetch" href="/learn-wgpu/assets/js/10.678bdd8f.js"><link rel="prefetch" href="/learn-wgpu/assets/js/11.ec5fc55d.js"><link rel="prefetch" href="/learn-wgpu/assets/js/12.d22a3360.js"><link rel="prefetch" href="/learn-wgpu/assets/js/13.d90a92db.js"><link rel="prefetch" href="/learn-wgpu/assets/js/16.70bfa427.js"><link rel="prefetch" href="/learn-wgpu/assets/js/17.a18d8432.js"><link rel="prefetch" href="/learn-wgpu/assets/js/18.4a711d00.js"><link rel="prefetch" href="/learn-wgpu/assets/js/19.067373fa.js"><link rel="prefetch" href="/learn-wgpu/assets/js/2.f5571f12.js"><link rel="prefetch" href="/learn-wgpu/assets/js/20.31e0a434.js"><link rel="prefetch" href="/learn-wgpu/assets/js/21.7b867c3c.js"><link rel="prefetch" href="/learn-wgpu/assets/js/23.abdd6762.js"><link rel="prefetch" href="/learn-wgpu/assets/js/24.38da801a.js"><link rel="prefetch" href="/learn-wgpu/assets/js/25.831771f8.js"><link rel="prefetch" href="/learn-wgpu/assets/js/26.275f1cf4.js"><link rel="prefetch" href="/learn-wgpu/assets/js/27.01d55187.js"><link rel="prefetch" href="/learn-wgpu/assets/js/28.2f1a8279.js"><link rel="prefetch" href="/learn-wgpu/assets/js/29.5ead4d92.js"><link rel="prefetch" href="/learn-wgpu/assets/js/3.b967f93a.js"><link rel="prefetch" href="/learn-wgpu/assets/js/30.2760ef2e.js"><link rel="prefetch" href="/learn-wgpu/assets/js/31.2cc77589.js"><link rel="prefetch" href="/learn-wgpu/assets/js/32.946ceeb1.js"><link rel="prefetch" href="/learn-wgpu/assets/js/33.4771159b.js"><link rel="prefetch" href="/learn-wgpu/assets/js/34.243b88c1.js"><link rel="prefetch" href="/learn-wgpu/assets/js/35.9375dd6a.js"><link rel="prefetch" href="/learn-wgpu/assets/js/36.a67ffba8.js"><link rel="prefetch" href="/learn-wgpu/assets/js/37.7a606210.js"><link rel="prefetch" href="/learn-wgpu/assets/js/38.948c9159.js"><link rel="prefetch" href="/learn-wgpu/assets/js/39.903e36ab.js"><link rel="prefetch" href="/learn-wgpu/assets/js/4.708fc98e.js"><link rel="prefetch" href="/learn-wgpu/assets/js/40.d38c5ac2.js"><link rel="prefetch" href="/learn-wgpu/assets/js/41.9da478f5.js"><link rel="prefetch" href="/learn-wgpu/assets/js/42.e5816a32.js"><link rel="prefetch" href="/learn-wgpu/assets/js/43.924905ff.js"><link rel="prefetch" href="/learn-wgpu/assets/js/44.1b27deea.js"><link rel="prefetch" href="/learn-wgpu/assets/js/45.582f637d.js"><link rel="prefetch" href="/learn-wgpu/assets/js/46.1b5427a5.js"><link rel="prefetch" href="/learn-wgpu/assets/js/47.4573b85b.js"><link rel="prefetch" href="/learn-wgpu/assets/js/48.2512ae5c.js"><link rel="prefetch" href="/learn-wgpu/assets/js/49.18553ca0.js"><link rel="prefetch" href="/learn-wgpu/assets/js/5.5b57042b.js"><link rel="prefetch" href="/learn-wgpu/assets/js/50.db3aad74.js"><link rel="prefetch" href="/learn-wgpu/assets/js/51.c989dae9.js"><link rel="prefetch" href="/learn-wgpu/assets/js/52.210f429e.js"><link rel="prefetch" href="/learn-wgpu/assets/js/53.4e6a0601.js"><link rel="prefetch" href="/learn-wgpu/assets/js/54.1361e722.js"><link rel="prefetch" href="/learn-wgpu/assets/js/55.be38bee2.js"><link rel="prefetch" href="/learn-wgpu/assets/js/56.17a3a050.js"><link rel="prefetch" href="/learn-wgpu/assets/js/57.2d662642.js"><link rel="prefetch" href="/learn-wgpu/assets/js/58.b8bfa489.js"><link rel="prefetch" href="/learn-wgpu/assets/js/59.a5740542.js"><link rel="prefetch" href="/learn-wgpu/assets/js/6.7df95f8a.js"><link rel="prefetch" href="/learn-wgpu/assets/js/60.d748f225.js"><link rel="prefetch" href="/learn-wgpu/assets/js/7.1495bbb2.js"><link rel="prefetch" href="/learn-wgpu/assets/js/8.963a7e56.js"><link rel="prefetch" href="/learn-wgpu/assets/js/9.c682788f.js">
    <link rel="stylesheet" href="/learn-wgpu/assets/css/1.styles.a09ac8f8.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="inner"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/learn-wgpu/" class="home-link router-link-active"><!----> <span class="site-name">Learn Wgpu</span></a> <div class="links"><!----> <div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div></div></div></header> <div class="sidebar-mask"></div> <div class="docs-layout"><aside class="sidebar"><!---->  <ul class="sidebar-links"><li><a href="/learn-wgpu/" aria-current="page" class="sidebar-link">Introduction</a></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Beginner</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/learn-wgpu/beginner/tutorial1-window/" class="sidebar-link">Dependencies and the window</a></li><li><a href="/learn-wgpu/beginner/tutorial2-surface/" class="sidebar-link">The Surface</a></li><li><a href="/learn-wgpu/beginner/tutorial3-pipeline/" class="sidebar-link">The Pipeline</a></li><li><a href="/learn-wgpu/beginner/tutorial4-buffer/" class="sidebar-link">Buffers and Indices</a></li><li><a href="/learn-wgpu/beginner/tutorial5-textures/" class="sidebar-link">Textures and bind groups</a></li><li><a href="/learn-wgpu/beginner/tutorial6-uniforms/" class="sidebar-link">Uniform buffers and a 3d camera</a></li><li><a href="/learn-wgpu/beginner/tutorial7-instancing/" class="sidebar-link">Instancing</a></li><li><a href="/learn-wgpu/beginner/tutorial8-depth/" class="sidebar-link">The Depth Buffer</a></li><li><a href="/learn-wgpu/beginner/tutorial9-models/" class="sidebar-link">Model Loading</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>Intermediate</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/learn-wgpu/intermediate/tutorial10-lighting/" class="sidebar-link">Working with Lights</a></li><li><a href="/learn-wgpu/intermediate/tutorial11-normals/" class="sidebar-link">Normal Mapping</a></li><li><a href="/learn-wgpu/intermediate/tutorial12-camera/" class="sidebar-link">A Better Camera</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Showcase</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>News</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="procedural-terrain"><a href="#procedural-terrain" class="header-anchor">#</a> Procedural Terrain</h1> <p>Up to this point we've been working in an empty void. This is great when you want to get your shading code just right, but most applications will want to fill the screen more interesting things. You could aproach this in a variety of ways. You could create a bunch of models in Blender and load them into the scene. This method works great if you have some decent artistic skills, and some patience. I'm lacking in both those departments, so let's write some code to make something that looks nice.</p> <p>As the name of this article suggests we're going to create a terrain. Now the traditional method to create a terrain mesh is to use a pre-generated noise texture and sampling it to get the height values at each point in the mesh. This is a perfectly valid way to approach this, but I opted to generate the noise using a Compute Shader directly. Let's get started!</p> <h2 id="compute-shaders"><a href="#compute-shaders" class="header-anchor">#</a> Compute Shaders</h2> <p>A compute shader is simply a shader that allows you to leverage the GPU's parallel computing power for arbitrary tasks. You can use them for anything from creating a texture to running a neural network. I'll get more into how they work in a bit, but for now suffice to say that we're going to use them to create the vertex and index buffers for our terrain.</p> <div class="note"><p>As of writing, compute shaders are still experimental on the web. You can enable them on beta versions of browsers such as Chrome Canary and Firefox Nightly. Because of this I'll cover a method to use a fragment shader to compute the vertex and index buffers after we cover the compute shader method.</p></div> <h2 id="noise-functions"><a href="#noise-functions" class="header-anchor">#</a> Noise Functions</h2> <p>Lets start with the shader code for the compute shader. First we'll create the noise functions, then we'll create the compute shader's entry function. Create a new file called <code>terrain.wgsl</code>. Then add the following:</p> <div class="language-wgsl extra-class"><pre class="language-text"><code>// ============================
// Terrain Generation
// ============================

// https://gist.github.com/munrocket/236ed5ba7e409b8bdf1ff6eca5dcdc39
//  MIT License. Â© Ian McEwan, Stefan Gustavson, Munrocket
// - Less condensed glsl implementation with comments can be found at https://weber.itn.liu.se/~stegu/jgt2012/article.pdf

fn permute3(x: vec3&lt;f32&gt;) -&gt; vec3&lt;f32&gt; { return (((x * 34.) + 1.) * x) % vec3&lt;f32&gt;(289.); }

fn snoise2(v: vec2&lt;f32&gt;) -&gt; f32 {
  let C = vec4&lt;f32&gt;(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439);
  var i: vec2&lt;f32&gt; = floor(v + dot(v, C.yy));
  let x0 = v - i + dot(i, C.xx);
  // I flipped the condition here from &gt; to &lt; as it fixed some artifacting I was observing
  var i1: vec2&lt;f32&gt; = select(vec2&lt;f32&gt;(1., 0.), vec2&lt;f32&gt;(0., 1.), (x0.x &lt; x0.y));
  var x12: vec4&lt;f32&gt; = x0.xyxy + C.xxzz - vec4&lt;f32&gt;(i1, 0., 0.);
  i = i % vec2&lt;f32&gt;(289.);
  let p = permute3(permute3(i.y + vec3&lt;f32&gt;(0., i1.y, 1.)) + i.x + vec3&lt;f32&gt;(0., i1.x, 1.));
  var m: vec3&lt;f32&gt; = max(0.5 -
      vec3&lt;f32&gt;(dot(x0, x0), dot(x12.xy, x12.xy), dot(x12.zw, x12.zw)), vec3&lt;f32&gt;(0.));
  m = m * m;
  m = m * m;
  let x = 2. * fract(p * C.www) - 1.;
  let h = abs(x) - 0.5;
  let ox = floor(x + 0.5);
  let a0 = x - ox;
  m = m * (1.79284291400159 - 0.85373472095314 * (a0 * a0 + h * h));
  let g = vec3&lt;f32&gt;(a0.x * x0.x + h.x * x0.y, a0.yz * x12.xz + h.yz * x12.yw);
  return 130. * dot(m, g);
}

</code></pre></div><p>Some of my readers may recognize this as an implementation of Simplex noise (specifically OpenSimplex noise). I'll admit to not really understanding the math behind OpenSimplex noise. The basics of it are that it's similar to Perlin Noise, but instead of a square grid it's a hexagonal grid which removes some of the artifacts that generating the noise on a square grid gets you. Again I'm not an expert on this, so to summarize: <code>permute3()</code> takes a <code>vec3</code> and returns a pseudorandom <code>vec3</code>, <code>snoise2()</code> takes a <code>vec2</code> and returns a floating point number between [-1, 1]. If you want to learn more about noise functions, check out <a href="https://thebookofshaders.com/11/" target="_blank" rel="noopener noreferrer">this article from The Book of Shaders<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>. The code's in GLSL, but the concepts are the same.</p> <p>While we can use the output of <code>snoise</code> directly to generate the terrains height values. The result of this tends to be very smooth, which may be what you want, but doesn't look very organic as you can see below:</p> <p><img src="/learn-wgpu/assets/img/figure_no-fbm.1931fe05.png" alt="smooth terrain"></p> <p>To make the terrain a bit rougher we're going to use a technique called <a href="https://thebookofshaders.com/13/" target="_blank" rel="noopener noreferrer">Fractal Brownian Motion<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>. This technique works by sampling the noise function multiple times cutting the strength in half each time while doubling the frequency of the noise. This means that the overall shape of the terrain will be fairly smooth, but it will have sharper details. You can see what that will look like below:</p> <p><img src="/learn-wgpu/assets/img/figure_fbm.28310498.png" alt="more organic terrain"></p> <p>The code for this function is actually quite simple:</p> <div class="language-wgsl extra-class"><pre class="language-text"><code>fn fbm(p: vec2&lt;f32&gt;) -&gt; f32 {
    let NUM_OCTAVES: u32 = 5u;
    var x = p * 0.01;
    var v = 0.0;
    var a = 0.5;
    let shift = vec2&lt;f32&gt;(100.0);
    let cs = vec2&lt;f32&gt;(cos(0.5), sin(0.5));
    let rot = mat2x2&lt;f32&gt;(cs.x, cs.y, -cs.y, cs.x);

    for (var i=0u; i&lt;NUM_OCTAVES; i=i+1u) {
        v = v + a * snoise2(x);
        x = rot * x * 2.0 + shift;
        a = a * 0.5;
    }

    return v;
}
</code></pre></div><p>Let's go over some this a bit:</p> <ul><li>The <code>NUM_OCTAVES</code> constant is the number of levels of noise you want. More octaves will add more texture to the terrain mesh, but you'll get diminishing returns at higher levels. I find that 5 is a good number.</li> <li>We multiple <code>p</code> by <code>0.01</code> to &quot;zoom in&quot; on the noise function. This is because as our mesh will be 1x1 quads and the simplex noise function resembles white noise when stepping by one each time. You can see what that looks like to use <code>p</code> directly: <img src="/learn-wgpu/assets/img/figure_spiky.46babb7a.png" alt="spiky terrain"></li> <li>The <code>a</code> variable is the amplitude of the noise at the given noise level.</li> <li><code>shift</code> and <code>rot</code> are used to reduce artifacts in the generated noise. One such artiface is that at <code>0,0</code> the output of the <code>snoise</code> will always be the same regardless of how much you scale <code>p</code>.</li></ul> <h2 id="generating-the-mesh"><a href="#generating-the-mesh" class="header-anchor">#</a> Generating the mesh</h2> <p>To generate the terrain mesh we're going to need to pass some information into the shader:</p> <div class="language-wgsl extra-class"><pre class="language-text"><code>struct ChunkData {
    chunk_size: vec2&lt;u32&gt;,
    chunk_corner: vec2&lt;i32&gt;,
    min_max_height: vec2&lt;f32&gt;,
}

struct Vertex {
    @location(0) position: vec3&lt;f32&gt;,
    @location(1) normal: vec3&lt;f32&gt;,
}

struct VertexBuffer {
    data: array&lt;Vertex&gt;, // stride: 32
}

struct IndexBuffer {
    data: array&lt;u32&gt;,
}

@group(0) @binding(0) var&lt;uniform&gt; chunk_data: ChunkData;
@group(0)@binding(1) var&lt;storage, read_write&gt; vertices: VertexBuffer;
@group(0)@binding(2) var&lt;storage, read_write&gt; indices: IndexBuffer;
</code></pre></div><p>Our shader will expect a <code>uniform</code> buffer that includes the size of the quad grid in <code>chunk_size</code>, the <code>chunk_corner</code> that our noise algorithm should start at, and <code>min_max_height</code> of the terrain.</p> <p>The vertex and index buffers are passed in as <code>storage</code> buffers with <code>read_write</code> enabled. We'll create the actual buffers in Rust and bind them when we execute the compute shader.</p> <p>The next part of the shader will be the functions that generate a point on the mesh, and a vertex at that point:</p> <div class="language-wgsl extra-class"><pre class="language-text"><code>fn terrain_point(p: vec2&lt;f32&gt;) -&gt; vec3&lt;f32&gt; {
    return vec3&lt;f32&gt;(
        p.x,
        mix(chunk_data.min_max_height.x,chunk_data.min_max_height.y, fbm(p)),
        p.y,
    );
}

fn terrain_vertex(p: vec2&lt;f32&gt;) -&gt; Vertex {
    let v = terrain_point(p);

    let tpx = terrain_point(p + vec2&lt;f32&gt;(0.1, 0.0)) - v;
    let tpz = terrain_point(p + vec2&lt;f32&gt;(0.0, 0.1)) - v;
    let tnx = terrain_point(p + vec2&lt;f32&gt;(-0.1, 0.0)) - v;
    let tnz = terrain_point(p + vec2&lt;f32&gt;(0.0, -0.1)) - v;

    let pn = normalize(cross(tpz, tpx));
    let nn = normalize(cross(tnz, tnx));

    let n = (pn + nn) * 0.5;

    return Vertex(v, n);
}
</code></pre></div><p>The <code>terrain_point</code> function takes an XZ point on the terrain and returns a <code>vec3</code> with the <code>y</code> value between the min and max height values.</p> <p><code>terrain_vertex</code> uses <code>terrain_point</code> to get it's position and also to compute of the normal of the surface by sampling 4 nearby points and uses them to compute the normal using some <a href="https://www.khanacademy.org/math/multivariable-calculus/thinking-about-multivariable-function/x786f2022:vectors-and-matrices/a/cross-products-mvc" target="_blank" rel="noopener noreferrer">cross products<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>.</p> <div class="note"><p>You'll notice that our <code>Vertex</code> struct doesn't include a texture coordinate. We could easily create texture coordinates by using the XZ coords of the vertices and having the texture sampler mirror the texture on the x and y axes, but heightmaps tend to have stretching when textured in this way.</p> <p>We'll cover a method called triplanar mapping to texture the terrain in a future tutorial. For now we'll just use a procedural texture that will create in the fragment shader we use to render the terrain.</p></div> <p>Now that we can get a vertex on the terrains surface we can fill our vertex and index buffers with actual data. We'll create a <code>gen_terrain()</code> function that will be the entry point for our compute shader:</p> <div class="language-wgsl extra-class"><pre class="language-text"><code>@compute @workgroup_size(64)
fn gen_terrain(
    @builtin(global_invocation_id) gid: vec3&lt;u32&gt;
) {
    // snipped...
}
</code></pre></div><p>We specify that <code>gen_terrain</code> is a compute shader entry point by annotating it with <code>stage(compute)</code>.</p> <p>The <code>workgroup_size()</code> is the number of workers that the GPU can allocate per <code>workgroup</code>. We specify the number of workers when we execute the compute shader. There are technically 3 parameters to this as work groups are a 3d grid, but if you don't specify them they default to 1. In other words <code>workgroup_size(64)</code> is equivalent to <code>workgroup_size(64, 1, 1)</code>.</p> <p>The <code>global_invocation_id</code> is a 3d index. This may seem weird, but you can think of work groups as a 3d grid of work groups. These workgroups have an internal grid of workers. The <code>global_invocation_id</code> is the id of the current worker relative to all the other works.</p> <p>Visually the workgroup grid would look something like this:</p> <p><img src="/learn-wgpu/assets/img/figure_work-groups.af52f221.jpg" alt="work group grid"></p> <div class="note"><p>It may be helpful to think of a compute shader as a function that is run in a bunch of nested for loops, but each loop is executed in parallel. It would look something like this:</p> <div class="language- extra-class"><pre class="language-text"><code>for wgx in num_workgroups.x:
    for wgy in num_workgroups.y:
        for wgz in num_workgroups.z:
            var local_invocation_id = (wgx, wgy, wgz)
            for x in workgroup_size.x:
                for y in workgroup_size.x:
                    for z in workgroup_size.x:
                        var global_invocation_id = local_invocation_id * workgroup_size + (x, y, z);
                        gen_terrain(global_invocation_id)

</code></pre></div><p>If you want learn more about workgroups <a href="https://www.w3.org/TR/WGSL/#compute-shader-workgroups" target="_blank" rel="noopener noreferrer">check out the docs<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>.</p></div> <p>TODO:</p> <ul><li>Note changes to <code>create_render_pipeline</code></li> <li>Mention <code>swizzle</code> feature for cgmath</li> <li>Compare workgroups and workgroups sizes to nested for loops
<ul><li>Maybe make a diagram in blender?</li></ul></li> <li>Change to camera movement speed</li></ul></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated: </span> <span class="time">10/20/2022, 4:12:57 PM</span></div></footer> <!----> </main></div></div><div class="global-ui"><!----></div></div>
    <script src="/learn-wgpu/assets/js/app.fbe9e6a8.js" defer></script><script src="/learn-wgpu/assets/js/15.656a9cc4.js" defer></script><script src="/learn-wgpu/assets/js/22.a7ceb9be.js" defer></script>
  </body>
</html>
